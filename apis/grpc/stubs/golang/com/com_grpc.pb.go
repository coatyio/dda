// SPDX-FileCopyrightText: Â© 2023 Siemens AG
// SPDX-License-Identifier: MIT

// Service definition of DDA Communication API.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.3
// source: com.proto

package com

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ComService_PublishEvent_FullMethodName        = "/dda.com.v1.ComService/PublishEvent"
	ComService_SubscribeEvent_FullMethodName      = "/dda.com.v1.ComService/SubscribeEvent"
	ComService_PublishAction_FullMethodName       = "/dda.com.v1.ComService/PublishAction"
	ComService_SubscribeAction_FullMethodName     = "/dda.com.v1.ComService/SubscribeAction"
	ComService_PublishActionResult_FullMethodName = "/dda.com.v1.ComService/PublishActionResult"
	ComService_PublishQuery_FullMethodName        = "/dda.com.v1.ComService/PublishQuery"
	ComService_SubscribeQuery_FullMethodName      = "/dda.com.v1.ComService/SubscribeQuery"
	ComService_PublishQueryResult_FullMethodName  = "/dda.com.v1.ComService/PublishQueryResult"
)

// ComServiceClient is the client API for ComService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ComServiceClient interface {
	// Publish the given Event and receive an acknowledgement after event has been
	// transmitted by the DDA communication service. PublishEvent does not wait
	// for the event to be received by subscribing gRPC clients.
	//
	// If the given event cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled.
	PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error)
	// Subscribe for receiving Event messages that match the given
	// SubscriptionFilter.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an event cannot be transmitted to the gRPC
	// client, the stream is aborted with status code UNAVAILABLE (14).
	//
	// To stop receiving events, a gRPC client should cancel this server streaming
	// call or specify a deadline/timeout with this call from the very start.
	SubscribeEvent(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeEventClient, error)
	// Publish the given Action and receive ActionResult messages.
	//
	// If the given action cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an action result cannot be transmitted to
	// the gRPC client, the stream is aborted.
	PublishAction(ctx context.Context, in *Action, opts ...grpc.CallOption) (ComService_PublishActionClient, error)
	// Subscribe for receiving Action messages sent by rpc PublishAction that
	// match the given SubscriptionFilter. Received Actions are augmented by an
	// opaque correlation id that must be passed to correlated action results.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an action cannot be transmitted to the
	// gRPC client, the stream is aborted.
	//
	// To stop receiving actions, a gRPC client should cancel this server
	// streaming call or specify a deadline/timeout with this call from the very
	// start.
	SubscribeAction(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeActionClient, error)
	// Publish the given action result correlated to an Action received by rpc
	// SubscribeAction and receive an acknowledgement after the result has been
	// transmitted by the DDA communication service.
	//
	// If the given correlation id is invalid, or if a final action result has
	// already been sent, a gRPC error with status code INVALID_ARGUMENT (3) is
	// signaled. If the action result cannot be transmitted by the DDA
	// communication service, a gRPC error with status code UNAVAILABLE (14) is
	// signaled.
	PublishActionResult(ctx context.Context, in *ActionResultCorrelated, opts ...grpc.CallOption) (*Ack, error)
	// Publish the given Query and receive QueryResult messages.
	//
	// If the given query cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If a query result cannot be transmitted to
	// the gRPC client, the stream is aborted.
	PublishQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (ComService_PublishQueryClient, error)
	// Subscribe for receiving Query messages sent by rpc PublishQuery that match
	// the given SubscriptionFilter. Received Queries are augmented by an opaque
	// correlation id that must be passed to correlated query results.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If a query cannot be transmitted to the gRPC
	// client, the stream is aborted.
	//
	// To stop receiving queries, a gRPC client should cancel this server
	// streaming call or specify a deadline/timeout with this call from the very
	// start.
	SubscribeQuery(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeQueryClient, error)
	// Publish the given query result correlated to a Query received by rpc
	// SubscribeQuery and receive an acknowledgement after the result has been
	// transmitted by the DDA communication service.
	//
	// If the given correlation id is invalid, or if a final query result has
	// already been sent, a gRPC error with status code INVALID_ARGUMENT (3) is
	// signaled. If the query result cannot be transmitted by the DDA
	// communication service, a gRPC error with status code UNAVAILABLE (14) is
	// signaled.
	PublishQueryResult(ctx context.Context, in *QueryResultCorrelated, opts ...grpc.CallOption) (*Ack, error)
}

type comServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewComServiceClient(cc grpc.ClientConnInterface) ComServiceClient {
	return &comServiceClient{cc}
}

func (c *comServiceClient) PublishEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, ComService_PublishEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *comServiceClient) SubscribeEvent(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &ComService_ServiceDesc.Streams[0], ComService_SubscribeEvent_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &comServiceSubscribeEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ComService_SubscribeEventClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type comServiceSubscribeEventClient struct {
	grpc.ClientStream
}

func (x *comServiceSubscribeEventClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *comServiceClient) PublishAction(ctx context.Context, in *Action, opts ...grpc.CallOption) (ComService_PublishActionClient, error) {
	stream, err := c.cc.NewStream(ctx, &ComService_ServiceDesc.Streams[1], ComService_PublishAction_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &comServicePublishActionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ComService_PublishActionClient interface {
	Recv() (*ActionResult, error)
	grpc.ClientStream
}

type comServicePublishActionClient struct {
	grpc.ClientStream
}

func (x *comServicePublishActionClient) Recv() (*ActionResult, error) {
	m := new(ActionResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *comServiceClient) SubscribeAction(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeActionClient, error) {
	stream, err := c.cc.NewStream(ctx, &ComService_ServiceDesc.Streams[2], ComService_SubscribeAction_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &comServiceSubscribeActionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ComService_SubscribeActionClient interface {
	Recv() (*ActionCorrelated, error)
	grpc.ClientStream
}

type comServiceSubscribeActionClient struct {
	grpc.ClientStream
}

func (x *comServiceSubscribeActionClient) Recv() (*ActionCorrelated, error) {
	m := new(ActionCorrelated)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *comServiceClient) PublishActionResult(ctx context.Context, in *ActionResultCorrelated, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, ComService_PublishActionResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *comServiceClient) PublishQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (ComService_PublishQueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &ComService_ServiceDesc.Streams[3], ComService_PublishQuery_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &comServicePublishQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ComService_PublishQueryClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type comServicePublishQueryClient struct {
	grpc.ClientStream
}

func (x *comServicePublishQueryClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *comServiceClient) SubscribeQuery(ctx context.Context, in *SubscriptionFilter, opts ...grpc.CallOption) (ComService_SubscribeQueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &ComService_ServiceDesc.Streams[4], ComService_SubscribeQuery_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &comServiceSubscribeQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ComService_SubscribeQueryClient interface {
	Recv() (*QueryCorrelated, error)
	grpc.ClientStream
}

type comServiceSubscribeQueryClient struct {
	grpc.ClientStream
}

func (x *comServiceSubscribeQueryClient) Recv() (*QueryCorrelated, error) {
	m := new(QueryCorrelated)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *comServiceClient) PublishQueryResult(ctx context.Context, in *QueryResultCorrelated, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, ComService_PublishQueryResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ComServiceServer is the server API for ComService service.
// All implementations must embed UnimplementedComServiceServer
// for forward compatibility
type ComServiceServer interface {
	// Publish the given Event and receive an acknowledgement after event has been
	// transmitted by the DDA communication service. PublishEvent does not wait
	// for the event to be received by subscribing gRPC clients.
	//
	// If the given event cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled.
	PublishEvent(context.Context, *Event) (*Ack, error)
	// Subscribe for receiving Event messages that match the given
	// SubscriptionFilter.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an event cannot be transmitted to the gRPC
	// client, the stream is aborted with status code UNAVAILABLE (14).
	//
	// To stop receiving events, a gRPC client should cancel this server streaming
	// call or specify a deadline/timeout with this call from the very start.
	SubscribeEvent(*SubscriptionFilter, ComService_SubscribeEventServer) error
	// Publish the given Action and receive ActionResult messages.
	//
	// If the given action cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an action result cannot be transmitted to
	// the gRPC client, the stream is aborted.
	PublishAction(*Action, ComService_PublishActionServer) error
	// Subscribe for receiving Action messages sent by rpc PublishAction that
	// match the given SubscriptionFilter. Received Actions are augmented by an
	// opaque correlation id that must be passed to correlated action results.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If an action cannot be transmitted to the
	// gRPC client, the stream is aborted.
	//
	// To stop receiving actions, a gRPC client should cancel this server
	// streaming call or specify a deadline/timeout with this call from the very
	// start.
	SubscribeAction(*SubscriptionFilter, ComService_SubscribeActionServer) error
	// Publish the given action result correlated to an Action received by rpc
	// SubscribeAction and receive an acknowledgement after the result has been
	// transmitted by the DDA communication service.
	//
	// If the given correlation id is invalid, or if a final action result has
	// already been sent, a gRPC error with status code INVALID_ARGUMENT (3) is
	// signaled. If the action result cannot be transmitted by the DDA
	// communication service, a gRPC error with status code UNAVAILABLE (14) is
	// signaled.
	PublishActionResult(context.Context, *ActionResultCorrelated) (*Ack, error)
	// Publish the given Query and receive QueryResult messages.
	//
	// If the given query cannot be transmitted, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If a query result cannot be transmitted to
	// the gRPC client, the stream is aborted.
	PublishQuery(*Query, ComService_PublishQueryServer) error
	// Subscribe for receiving Query messages sent by rpc PublishQuery that match
	// the given SubscriptionFilter. Received Queries are augmented by an opaque
	// correlation id that must be passed to correlated query results.
	//
	// If the given subscription cannot be set up, a gRPC error with status code
	// UNAVAILABLE (14) is signaled. If a query cannot be transmitted to the gRPC
	// client, the stream is aborted.
	//
	// To stop receiving queries, a gRPC client should cancel this server
	// streaming call or specify a deadline/timeout with this call from the very
	// start.
	SubscribeQuery(*SubscriptionFilter, ComService_SubscribeQueryServer) error
	// Publish the given query result correlated to a Query received by rpc
	// SubscribeQuery and receive an acknowledgement after the result has been
	// transmitted by the DDA communication service.
	//
	// If the given correlation id is invalid, or if a final query result has
	// already been sent, a gRPC error with status code INVALID_ARGUMENT (3) is
	// signaled. If the query result cannot be transmitted by the DDA
	// communication service, a gRPC error with status code UNAVAILABLE (14) is
	// signaled.
	PublishQueryResult(context.Context, *QueryResultCorrelated) (*Ack, error)
	mustEmbedUnimplementedComServiceServer()
}

// UnimplementedComServiceServer must be embedded to have forward compatible implementations.
type UnimplementedComServiceServer struct {
}

func (UnimplementedComServiceServer) PublishEvent(context.Context, *Event) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishEvent not implemented")
}
func (UnimplementedComServiceServer) SubscribeEvent(*SubscriptionFilter, ComService_SubscribeEventServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeEvent not implemented")
}
func (UnimplementedComServiceServer) PublishAction(*Action, ComService_PublishActionServer) error {
	return status.Errorf(codes.Unimplemented, "method PublishAction not implemented")
}
func (UnimplementedComServiceServer) SubscribeAction(*SubscriptionFilter, ComService_SubscribeActionServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeAction not implemented")
}
func (UnimplementedComServiceServer) PublishActionResult(context.Context, *ActionResultCorrelated) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishActionResult not implemented")
}
func (UnimplementedComServiceServer) PublishQuery(*Query, ComService_PublishQueryServer) error {
	return status.Errorf(codes.Unimplemented, "method PublishQuery not implemented")
}
func (UnimplementedComServiceServer) SubscribeQuery(*SubscriptionFilter, ComService_SubscribeQueryServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeQuery not implemented")
}
func (UnimplementedComServiceServer) PublishQueryResult(context.Context, *QueryResultCorrelated) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishQueryResult not implemented")
}
func (UnimplementedComServiceServer) mustEmbedUnimplementedComServiceServer() {}

// UnsafeComServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ComServiceServer will
// result in compilation errors.
type UnsafeComServiceServer interface {
	mustEmbedUnimplementedComServiceServer()
}

func RegisterComServiceServer(s grpc.ServiceRegistrar, srv ComServiceServer) {
	s.RegisterService(&ComService_ServiceDesc, srv)
}

func _ComService_PublishEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComServiceServer).PublishEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComService_PublishEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComServiceServer).PublishEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComService_SubscribeEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ComServiceServer).SubscribeEvent(m, &comServiceSubscribeEventServer{stream})
}

type ComService_SubscribeEventServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type comServiceSubscribeEventServer struct {
	grpc.ServerStream
}

func (x *comServiceSubscribeEventServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _ComService_PublishAction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Action)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ComServiceServer).PublishAction(m, &comServicePublishActionServer{stream})
}

type ComService_PublishActionServer interface {
	Send(*ActionResult) error
	grpc.ServerStream
}

type comServicePublishActionServer struct {
	grpc.ServerStream
}

func (x *comServicePublishActionServer) Send(m *ActionResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ComService_SubscribeAction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ComServiceServer).SubscribeAction(m, &comServiceSubscribeActionServer{stream})
}

type ComService_SubscribeActionServer interface {
	Send(*ActionCorrelated) error
	grpc.ServerStream
}

type comServiceSubscribeActionServer struct {
	grpc.ServerStream
}

func (x *comServiceSubscribeActionServer) Send(m *ActionCorrelated) error {
	return x.ServerStream.SendMsg(m)
}

func _ComService_PublishActionResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionResultCorrelated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComServiceServer).PublishActionResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComService_PublishActionResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComServiceServer).PublishActionResult(ctx, req.(*ActionResultCorrelated))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComService_PublishQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ComServiceServer).PublishQuery(m, &comServicePublishQueryServer{stream})
}

type ComService_PublishQueryServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type comServicePublishQueryServer struct {
	grpc.ServerStream
}

func (x *comServicePublishQueryServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ComService_SubscribeQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ComServiceServer).SubscribeQuery(m, &comServiceSubscribeQueryServer{stream})
}

type ComService_SubscribeQueryServer interface {
	Send(*QueryCorrelated) error
	grpc.ServerStream
}

type comServiceSubscribeQueryServer struct {
	grpc.ServerStream
}

func (x *comServiceSubscribeQueryServer) Send(m *QueryCorrelated) error {
	return x.ServerStream.SendMsg(m)
}

func _ComService_PublishQueryResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResultCorrelated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComServiceServer).PublishQueryResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComService_PublishQueryResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComServiceServer).PublishQueryResult(ctx, req.(*QueryResultCorrelated))
	}
	return interceptor(ctx, in, info, handler)
}

// ComService_ServiceDesc is the grpc.ServiceDesc for ComService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ComService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dda.com.v1.ComService",
	HandlerType: (*ComServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PublishEvent",
			Handler:    _ComService_PublishEvent_Handler,
		},
		{
			MethodName: "PublishActionResult",
			Handler:    _ComService_PublishActionResult_Handler,
		},
		{
			MethodName: "PublishQueryResult",
			Handler:    _ComService_PublishQueryResult_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeEvent",
			Handler:       _ComService_SubscribeEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PublishAction",
			Handler:       _ComService_PublishAction_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeAction",
			Handler:       _ComService_SubscribeAction_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PublishQuery",
			Handler:       _ComService_PublishQuery_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeQuery",
			Handler:       _ComService_SubscribeQuery_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "com.proto",
}
